{
  "address": "0xe98580b28B1EF0D57C7196c97f0781F59ea96a93",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes32[]",
          "name": "hashes",
          "type": "bytes32[]"
        }
      ],
      "name": "calculateRootFromPowerOfTwo",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_index",
          "type": "uint256"
        }
      ],
      "name": "getEmptyTreeHashAtIndex",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_wordIndex",
          "type": "uint256"
        }
      ],
      "name": "getHashOfWordAtIndex",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_data",
          "type": "bytes"
        },
        {
          "internalType": "uint8",
          "name": "_log2Size",
          "type": "uint8"
        }
      ],
      "name": "getMerkleRootFromBytes",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint8",
          "name": "_log2Size",
          "type": "uint8"
        }
      ],
      "name": "getPristineHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_position",
          "type": "uint64"
        },
        {
          "internalType": "bytes8",
          "name": "_value",
          "type": "bytes8"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "getRoot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint64",
          "name": "_position",
          "type": "uint64"
        },
        {
          "internalType": "uint8",
          "name": "_logOfSize",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "_drive",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32[]",
          "name": "siblings",
          "type": "bytes32[]"
        }
      ],
      "name": "getRootWithDrive",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x5623062ae6f12b5497ed840ecb680fd0799bfb037a0ce577127e400a5727f004",
  "receipt": {
    "to": null,
    "from": "0x18930e8a66a1DbE21D00581216789AAB7460Afd0",
    "contractAddress": "0xe98580b28B1EF0D57C7196c97f0781F59ea96a93",
    "transactionIndex": 10,
    "gasUsed": "1602504",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x36996c39cd33e233c58e1a76b64ccb63358df94988aadb10e30c32b0c2f7fe7b",
    "transactionHash": "0x5623062ae6f12b5497ed840ecb680fd0799bfb037a0ce577127e400a5727f004",
    "logs": [],
    "blockNumber": 8447849,
    "cumulativeGasUsed": "7474971",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "56083d6a911340537af81b340b5f270d",
  "metadata": "{\"compiler\":{\"version\":\"0.8.3+commit.8d00100c\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"hashes\",\"type\":\"bytes32[]\"}],\"name\":\"calculateRootFromPowerOfTwo\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getEmptyTreeHashAtIndex\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_wordIndex\",\"type\":\"uint256\"}],\"name\":\"getHashOfWordAtIndex\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"_log2Size\",\"type\":\"uint8\"}],\"name\":\"getMerkleRootFromBytes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_log2Size\",\"type\":\"uint8\"}],\"name\":\"getPristineHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_position\",\"type\":\"uint64\"},{\"internalType\":\"bytes8\",\"name\":\"_value\",\"type\":\"bytes8\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"getRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_position\",\"type\":\"uint64\"},{\"internalType\":\"uint8\",\"name\":\"_logOfSize\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"_drive\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"siblings\",\"type\":\"bytes32[]\"}],\"name\":\"getRootWithDrive\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calculateRootFromPowerOfTwo(bytes32[])\":{\"params\":{\"hashes\":\"The array containing power of 2 elements\"},\"returns\":{\"_0\":\"byte32 the root hash being calculated\"}},\"getEmptyTreeHashAtIndex(uint256)\":{\"details\":\"first index is keccak(0), second index is keccak(keccak(0), keccak(0))\",\"params\":{\"_index\":\"of hash wanted\"}},\"getHashOfWordAtIndex(bytes,uint256)\":{\"details\":\"if word is incomplete (< 8 bytes) it gets padded with zeroes\",\"params\":{\"_data\":\"array of bytes\",\"_wordIndex\":\"index of word inside the bytes to get the hash of\"}},\"getMerkleRootFromBytes(bytes,uint8)\":{\"details\":\"_data is padded with zeroes until is multiple of 8root is completed with zero tree until log2size is completehashes are taken word by word (8 bytes by 8 bytes)\",\"params\":{\"_data\":\"array of bytes to be merklelized\",\"_log2Size\":\"log2 of total size of the drive\"}},\"getPristineHash(uint8)\":{\"details\":\"using the precomputed EMPTY_TREE_HASHES is cheaper\",\"params\":{\"_log2Size\":\"log2 of size of the empty drive\"},\"returns\":{\"_0\":\"merkle root hash of the drive of size 1 << log2Size filled with zeros\"}},\"getRoot(uint64,bytes8,bytes32[])\":{\"params\":{\"_position\":\"position of word in drive\",\"_value\":\"word to include in drive\",\"proof\":\"array of siblings to generate merkle root\"},\"returns\":{\"_0\":\"new merkle root hash after _value inclusion\"}},\"getRootWithDrive(uint64,uint8,bytes32,bytes32[])\":{\"params\":{\"_drive\":\"drive to be included\",\"_logOfSize\":\"log2 of size of _drive\",\"_position\":\"position of _drive\",\"siblings\":\"_drive's so that merkle root can be calculated\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"calculateRootFromPowerOfTwo(bytes32[])\":{\"notice\":\"Calculate the root of Merkle tree from an array of power of 2 elements\"},\"getEmptyTreeHashAtIndex(uint256)\":{\"notice\":\"Gets precomputed hash of zero in empty tree hashes\"},\"getHashOfWordAtIndex(bytes,uint256)\":{\"notice\":\"Get the hash of a word in an array of bytes\"},\"getMerkleRootFromBytes(bytes,uint8)\":{\"notice\":\"get merkle root of generic array of bytes\"},\"getPristineHash(uint8)\":{\"notice\":\"Gets the pristine hash of a drive full of zeroes\"},\"getRoot(uint64,bytes8,bytes32[])\":{\"notice\":\"Gets merkle root of drive with _value on _position\"},\"getRootWithDrive(uint64,uint8,bytes32,bytes32[])\":{\"notice\":\"Gets merkle root hash of machine with drive _drive\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Merkle.sol\":\"Merkle\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/utils/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x2526b7c6a366fc211bbc176078ab02b83833e7682abcc5b3bed9d700b34e2a3e\",\"license\":\"MIT\"},\"contracts/CartesiMath.sol\":{\"content\":\"// Copyright 2020 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title CartesiMath\\n/// @author Felipe Argento\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\n\\nlibrary CartesiMath {\\n    using SafeMath for uint256;\\n\\n    // mapping values are packed as bytes3 each\\n    // see test/TestCartesiMath.ts for decimal values\\n    bytes constant log2tableTimes1M =\\n        hex\\\"0000000F4240182F421E8480236E082771822AD63A2DC6C0305E8532B04834C96736B3C23876D73A187A3B9D4A3D09003E5EA63FA0C540D17741F28843057D440BA745062945F60246DC1047B917488DC7495ABA4A207C4ADF8A4B98544C4B404CF8AA4DA0E64E44434EE3054F7D6D5013B750A61A5134C851BFF05247BD52CC58534DE753CC8D54486954C19C55384255AC75561E50568DE956FB575766B057D00758376F589CFA5900BA5962BC59C3135A21CA5A7EF15ADA945B34BF5B8D805BE4DF5C3AEA5C8FA95CE3265D356C5D86835DD6735E25455E73005EBFAD5F0B525F55F75F9FA25FE85A60302460770860BD0A61023061467F6189FD61CCAE620E98624FBF62902762CFD5630ECD634D12638AA963C7966403DC643F7F647A8264B4E864EEB56527EC6560906598A365D029660724663D9766738566A8F066DDDA6712476746386779AF67ACAF67DF3A6811526842FA68743268A4FC68D55C6905536934E169640A6992CF69C13169EF326A1CD46A4A186A76FF6AA38C6ACFC0\\\";\\n\\n    /// @notice Approximates log2 * 1M\\n    /// @param _num number to take log2 * 1M of\\n    /// @return approximate log2 times 1M\\n    function log2ApproxTimes1M(uint256 _num) public pure returns (uint256) {\\n        require(_num > 0, \\\"Number cannot be zero\\\");\\n        uint256 leading = 0;\\n\\n        if (_num == 1) return 0;\\n\\n        while (_num > 128) {\\n            _num = _num >> 1;\\n            leading += 1;\\n        }\\n        return (leading.mul(uint256(1000000))).add(getLog2TableTimes1M(_num));\\n    }\\n\\n    /// @notice navigates log2tableTimes1M\\n    /// @param _num number to take log2 of\\n    /// @return result after table look-up\\n    function getLog2TableTimes1M(uint256 _num) public pure returns (uint256) {\\n        bytes3 result = 0;\\n        for (uint8 i = 0; i < 3; i++) {\\n            bytes3 tempResult = log2tableTimes1M[(_num - 1) * 3 + i];\\n            result = result | (tempResult >> (i * 8));\\n        }\\n\\n        return uint256(uint24(result));\\n    }\\n\\n    /// @notice get floor of log2 of number\\n    /// @param _num number to take floor(log2) of\\n    /// @return floor(log2) of _num\\n   function getLog2Floor(uint256 _num) public pure returns (uint8) {\\n       require(_num != 0, \\\"log of zero is undefined\\\");\\n\\n       return uint8(255 - clz(_num));\\n    }\\n\\n    /// @notice checks if a number is Power of 2\\n    /// @param _num number to check\\n    /// @return true if number is power of 2, false if not\\n    function isPowerOf2(uint256 _num) public pure returns (bool) {\\n        if (_num == 0) return false;\\n\\n        return _num & (_num - 1) == 0;\\n    }\\n\\n    /// @notice count trailing zeros\\n    /// @param _num number you want the ctz of\\n    /// @dev this a binary search implementation\\n    function ctz(uint256 _num) public pure returns (uint256) {\\n        if (_num == 0) return 256;\\n\\n        uint256 n = 0;\\n        if (_num & 0x00000000000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF == 0) { n = n + 128; _num = _num >> 128; }\\n        if (_num & 0x000000000000000000000000000000000000000000000000FFFFFFFFFFFFFFFF == 0) { n = n + 64; _num = _num >> 64; }\\n        if (_num & 0x00000000000000000000000000000000000000000000000000000000FFFFFFFF == 0) { n = n + 32; _num = _num >> 32; }\\n        if (_num & 0x000000000000000000000000000000000000000000000000000000000000FFFF == 0) { n = n + 16; _num = _num >> 16; }\\n        if (_num & 0x00000000000000000000000000000000000000000000000000000000000000FF == 0) { n = n +  8; _num = _num >>  8; }\\n        if (_num & 0x000000000000000000000000000000000000000000000000000000000000000F == 0) { n = n +  4; _num = _num >>  4; }\\n        if (_num & 0x0000000000000000000000000000000000000000000000000000000000000003 == 0) { n = n +  2; _num = _num >>  2; }\\n        if (_num & 0x0000000000000000000000000000000000000000000000000000000000000001 == 0) { n = n +  1; }\\n\\n        return n;\\n    }\\n\\n    /// @notice count leading zeros\\n    /// @param _num number you want the clz of\\n    /// @dev this a binary search implementation\\n    function clz(uint256 _num) public pure returns (uint256) {\\n        if (_num == 0) return 256;\\n\\n        uint256 n = 0;\\n        if (_num & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000 == 0) { n = n + 128; _num = _num << 128; }\\n        if (_num & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000 == 0) { n = n + 64; _num = _num << 64; }\\n        if (_num & 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000 == 0) { n = n + 32; _num = _num << 32; }\\n        if (_num & 0xFFFF000000000000000000000000000000000000000000000000000000000000 == 0) { n = n + 16; _num = _num << 16; }\\n        if (_num & 0xFF00000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  8; _num = _num <<  8; }\\n        if (_num & 0xF000000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  4; _num = _num <<  4; }\\n        if (_num & 0xC000000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  2; _num = _num <<  2; }\\n        if (_num & 0x8000000000000000000000000000000000000000000000000000000000000000 == 0) { n = n +  1; }\\n\\n        return n;\\n    }\\n}\\n\",\"keccak256\":\"0xca784f2c33319c7e0501f836b6527dc39b1f0ae5768e2a16b87a7b3a9b2f73ad\",\"license\":\"Apache-2.0\"},\"contracts/Merkle.sol\":{\"content\":\"// Copyright 2020 Cartesi Pte. Ltd.\\n\\n// SPDX-License-Identifier: Apache-2.0\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\"); you may not use\\n// this file except in compliance with the License. You may obtain a copy of the\\n// License at http://www.apache.org/licenses/LICENSE-2.0\\n\\n// Unless required by applicable law or agreed to in writing, software distributed\\n// under the License is distributed on an \\\"AS IS\\\" BASIS, WITHOUT WARRANTIES OR\\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\\n// specific language governing permissions and limitations under the License.\\n\\n/// @title Library for Merkle proofs\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./CartesiMath.sol\\\";\\n\\nlibrary Merkle {\\n    using CartesiMath for uint256;\\n    using SafeMath for uint256;\\n\\n    uint256 constant L_WORD_SIZE = 3; // word = 8 bytes, log = 3\\n\\n    // merkle root hashes of trees of zero concatenated\\n    // 32 bytes for each root, first one is keccak(0), second one is\\n    // keccak(keccack(0), keccak(0)) and so on\\n\\n    bytes constant EMPTY_TREE_HASHES =\\n        hex\\\"011b4d03dd8c01f1049143cf9c4c817e4b167f1d1b83e5c6f0f10d89ba1e7bce4d9470a821fbe90117ec357e30bad9305732fb19ddf54a07dd3e29f440619254ae39ce8537aca75e2eff3e38c98011dfe934e700a0967732fc07b430dd656a233fc9a15f5b4869c872f81087bb6104b7d63e6f9ab47f2c43f3535eae7172aa7f17d2dd614cddaa4d879276b11e0672c9560033d3e8453a1d045339d34ba601b9c37b8b13ca95166fb7af16988a70fcc90f38bf9126fd833da710a47fb37a55e68e7a427fa943d9966b389f4f257173676090c6e95f43e2cb6d65f8758111e30930b0b9deb73e155c59740bacf14a6ff04b64bb8e201a506409c3fe381ca4ea90cd5deac729d0fdaccc441d09d7325f41586ba13c801b7eccae0f95d8f3933efed8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e6163e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b72122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec517a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca892b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e152499af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8bf065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a233e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698caefdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d33abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf98dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f65d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f649929927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e6191b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c99876e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977ec61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f945ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f8647bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348cafff75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172dafa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e2496d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f6d1ab973982c7ccbe6c1fae02788e4422ae22282fa49cbdb04ba54a7a238c6fc41187451383460762c06d1c8a72b9cd718866ad4b689e10c9a8c38fe5ef045bd785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683916ca832592485093644e8760cd7b4c01dba1ccc82b661bf13f0e3f34acd6b88\\\";\\n\\n    // number of hashes in EMPTY_TREE_HASHES\\n    uint256 constant EMPTY_TREE_SIZE = 61 * 32; // 32 bytes per 61 indexes (64 words)\\n\\n    /// @notice Gets the pristine hash of a drive full of zeroes\\n    /// @param _log2Size log2 of size of the empty drive\\n    /// @return merkle root hash of the drive of size 1 << log2Size filled with zeros\\n    /// @dev using the precomputed EMPTY_TREE_HASHES is cheaper\\n    function getPristineHash(uint8 _log2Size) public pure returns (bytes32) {\\n        require(_log2Size >= 3, \\\"Has to be at least one word\\\");\\n        require(_log2Size <= 64, \\\"Cannot be bigger than the machine itself\\\");\\n\\n        bytes8 value = 0;\\n        bytes32 runningHash = keccak256(abi.encodePacked(value));\\n\\n        for (uint256 i = 3; i < _log2Size; i++) {\\n            runningHash = keccak256(abi.encodePacked(runningHash, runningHash));\\n        }\\n\\n        return runningHash;\\n    }\\n\\n    /// @notice Gets merkle root of drive with _value on _position\\n    /// @param _position position of word in drive\\n    /// @param _value word to include in drive\\n    /// @param proof array of siblings to generate merkle root\\n    /// @return new merkle root hash after _value inclusion\\n    function getRoot(\\n        uint64 _position,\\n        bytes8 _value,\\n        bytes32[] memory proof\\n    ) public pure returns (bytes32) {\\n        bytes32 runningHash = keccak256(abi.encodePacked(_value));\\n\\n        return getRootWithDrive(_position, 3, runningHash, proof);\\n    }\\n\\n    /// @notice Gets merkle root hash of machine with drive _drive\\n    /// @param _position position of _drive\\n    /// @param _logOfSize log2 of size of _drive\\n    /// @param _drive drive to be included\\n    /// @param siblings _drive's so that merkle root can be calculated\\n    function getRootWithDrive(\\n        uint64 _position,\\n        uint8 _logOfSize,\\n        bytes32 _drive,\\n        bytes32[] memory siblings\\n    ) public pure returns (bytes32) {\\n        require(_logOfSize >= 3, \\\"Must be at least a word\\\");\\n        require(_logOfSize <= 64, \\\"Cannot be bigger than the machine itself\\\");\\n\\n        uint64 size = uint64(2)**_logOfSize;\\n\\n        require(((size - 1) & _position) == 0, \\\"Position is not aligned\\\");\\n        require(\\n            siblings.length == 64 - _logOfSize,\\n            \\\"Proof length does not match\\\"\\n        );\\n\\n        bytes32 drive = _drive;\\n\\n        for (uint64 i = 0; i < siblings.length; i++) {\\n            if ((_position & (size << i)) == 0) {\\n                drive = keccak256(abi.encodePacked(drive, siblings[i]));\\n            } else {\\n                drive = keccak256(abi.encodePacked(siblings[i], drive));\\n            }\\n        }\\n\\n        return drive;\\n    }\\n\\n    /// @notice Gets precomputed hash of zero in empty tree hashes\\n    /// @param _index of hash wanted\\n    /// @dev first index is keccak(0), second index is keccak(keccak(0), keccak(0))\\n    function getEmptyTreeHashAtIndex(uint256 _index)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        uint256 start = _index.mul(32);\\n        require(EMPTY_TREE_SIZE >= start.add(32), \\\"index out of bounds\\\");\\n        bytes32 hashedZeros;\\n        bytes memory zeroTree = EMPTY_TREE_HASHES;\\n\\n        // first word is length, then skip index words\\n        assembly {\\n            hashedZeros := mload(add(add(zeroTree, 0x20), start))\\n        }\\n        return hashedZeros;\\n    }\\n\\n    /// @notice get merkle root of generic array of bytes\\n    /// @param _data array of bytes to be merklelized\\n    /// @param _log2Size log2 of total size of the drive\\n    /// @dev _data is padded with zeroes until is multiple of 8\\n    /// @dev root is completed with zero tree until log2size is complete\\n    /// @dev hashes are taken word by word (8 bytes by 8 bytes)\\n    function getMerkleRootFromBytes(bytes calldata _data, uint8 _log2Size)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        require(_log2Size >= 3, \\\"Must be at least a word\\\");\\n        require(_log2Size <= 64, \\\"Cannot be bigger than the machine itself\\\");\\n\\n        // if _data is empty return pristine drive of size log2size\\n        if (_data.length == 0) return getEmptyTreeHashAtIndex(_log2Size - 3);\\n\\n        // total size of the drive in words\\n        uint256 size = 1 << uint256(_log2Size - 3);\\n        require(\\n            size << L_WORD_SIZE >= _data.length,\\n            \\\"data is bigger than drive\\\"\\n        );\\n        // the stack depth is log2(_data.length / 8) + 2\\n        uint256 stack_depth =\\n            2 + ((_data.length) >> L_WORD_SIZE).getLog2Floor();\\n        bytes32[] memory stack = new bytes32[](stack_depth);\\n\\n        uint256 numOfHashes; // total number of hashes on stack (counting levels)\\n        uint256 stackLength; // total length of stack\\n        uint256 numOfJoins; // number of hashes of the same level on stack\\n        uint256 topStackLevel; // hash level of the top of the stack\\n\\n        while (numOfHashes < size) {\\n            if ((numOfHashes << L_WORD_SIZE) < _data.length) {\\n                // we still have words to hash\\n                stack[stackLength] = getHashOfWordAtIndex(_data, numOfHashes);\\n                numOfHashes++;\\n\\n                numOfJoins = numOfHashes;\\n            } else {\\n                // since padding happens in hashOfWordAtIndex function\\n                // we only need to complete the stack with pre-computed\\n                // hash(0), hash(hash(0),hash(0)) and so on\\n                topStackLevel = numOfHashes.ctz();\\n\\n                stack[stackLength] = getEmptyTreeHashAtIndex(topStackLevel);\\n\\n                //Empty Tree Hash summarizes many hashes\\n                numOfHashes = numOfHashes.add(1 << topStackLevel);\\n                numOfJoins = numOfHashes >> topStackLevel;\\n            }\\n\\n            stackLength++;\\n\\n            // while there are joins, hash top of stack together\\n            while (numOfJoins & 1 == 0) {\\n                bytes32 h2 = stack[stackLength - 1];\\n                bytes32 h1 = stack[stackLength - 2];\\n\\n                stack[stackLength - 2] = keccak256(abi.encodePacked(h1, h2));\\n                stackLength = stackLength.sub(1); // remove hashes from stack\\n\\n                numOfJoins = numOfJoins >> 1;\\n            }\\n        }\\n        require(\\n            stackLength == 1,\\n            \\\"function ended but stack has more than one element\\\"\\n        );\\n\\n        return stack[0];\\n    }\\n\\n    /// @notice Get the hash of a word in an array of bytes\\n    /// @param _data array of bytes\\n    /// @param _wordIndex index of word inside the bytes to get the hash of\\n    /// @dev if word is incomplete (< 8 bytes) it gets padded with zeroes\\n    function getHashOfWordAtIndex(bytes calldata _data, uint256 _wordIndex)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        uint256 start = _wordIndex << L_WORD_SIZE;\\n        uint256 end = start.add(1 << L_WORD_SIZE);\\n\\n        // TODO: in .lua this just returns zero, but this might be more consistent\\n        require(start <= _data.length, \\\"word out of bounds\\\");\\n\\n        if (end <= _data.length) {\\n            return keccak256(abi.encodePacked(_data[start:end]));\\n        }\\n\\n        // word is incomplete\\n        // fill paddedSlice with incomplete words - the rest is going to be bytes(0)\\n        bytes memory paddedSlice = new bytes(8);\\n        uint256 remaining = _data.length.sub(start);\\n\\n        for (uint256 i = 0; i < remaining; i++) {\\n            paddedSlice[i] = _data[start.add(i)];\\n        }\\n\\n        return keccak256(paddedSlice);\\n    }\\n\\n    /// @notice Calculate the root of Merkle tree from an array of power of 2 elements\\n    /// @param hashes The array containing power of 2 elements\\n    /// @return byte32 the root hash being calculated\\n    function calculateRootFromPowerOfTwo(bytes32[] memory hashes)\\n        public\\n        pure\\n        returns (bytes32)\\n    {\\n        // revert when the input is not of power of 2\\n        require(\\n            (hashes.length).isPowerOf2(),\\n            \\\"The input array must contain power of 2 elements\\\"\\n        );\\n\\n        if (hashes.length == 1) {\\n            return hashes[0];\\n        } else {\\n            bytes32[] memory newHashes = new bytes32[](hashes.length >> 1);\\n\\n            for (uint256 i = 0; i < hashes.length; i += 2) {\\n                newHashes[i >> 1] = keccak256(\\n                    abi.encodePacked(hashes[i], hashes[i + 1])\\n                );\\n            }\\n\\n            return calculateRootFromPowerOfTwo(newHashes);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x63b9120e57124ad19aba14f3be018af100d492924f2665e33a9ab56d67ed148f\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x611c0561003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c806382b0eab81161006557806382b0eab8146100d75780638492d93b146100ea578063a7342688146100fd578063d7304dd91461011057610087565b806334bd712d1461008c578063451a1055146100b157806349fd2697146100c4575b600080fd5b61009f61009a366004610f7d565b610123565b60405190815260200160405180910390f35b61009f6100bf36600461101a565b610291565b61009f6100d2366004610fc6565b610324565b61009f6100e5366004610f23565b6107f9565b61009f6100f836600461104a565b610a6a565b61009f61010b36600461111a565b610ab3565b61009f61011e3660046110b3565b610ba9565b6000600382901b81610136826008610e05565b9050848211156101825760405162461bcd60e51b8152602060048201526012602482015271776f7264206f7574206f6620626f756e647360701b60448201526064015b60405180910390fd5b8481116101c557610195818387896111aa565b6040516020016101a6929190611152565b604051602081830303815290604052805190602001209250505061028a565b60408051600880825281830190925260009160208201818036833701905050905060006101f28785610e11565b905060005b8181101561027b57888861020b8784610e05565b81811061022857634e487b7160e01b600052603260045260246000fd5b9050013560f81c60f81b83828151811061025257634e487b7160e01b600052603260045260246000fd5b60200101906001600160f81b031916908160001a90535080610273816113af565b9150506101f7565b50508051602090910120925050505b9392505050565b60008061029f836020610e1d565b90506102ac816020610e05565b6107a010156102f35760405162461bcd60e51b8152602060048201526013602482015272696e646578206f7574206f6620626f756e647360681b6044820152606401610179565b600080604051806107c001604052806107a081526020016114306107a091399290920160200151925050505b919050565b600060038260ff1610156103745760405162461bcd60e51b8152602060048201526017602482015276135d5cdd08189948185d081b19585cdd0818481ddbdc99604a1b6044820152606401610179565b60408260ff1611156103985760405162461bcd60e51b815260040161017990611162565b826103ba576103b36103ab60038461138c565b60ff16610291565b905061028a565b60006103c760038461138c565b60ff166001901b905084849050600382901b10156104275760405162461bcd60e51b815260206004820152601960248201527f6461746120697320626967676572207468616e206472697665000000000000006044820152606401610179565b6040516306c8e54b60e01b8152600385901c60048201526000907347573276feC7E1bEa2E33B3c3945d4aBFDdA5941906306c8e54b9060240160206040518083038186803b15801561047857600080fd5b505af415801561048c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b09190611136565b6104bb9060026111ea565b60ff1690506000816001600160401b038111156104e857634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015610511578160200160208202803683370190505b5090506000806000805b8684101561075557600384901b8a111561057a5761053a8b8b86610123565b85848151811061055a57634e487b7160e01b600052603260045260246000fd5b60209081029190910101528361056f816113af565b945050839150610648565b60405163052dcf5f60e31b8152600481018590527347573276feC7E1bEa2E33B3c3945d4aBFDdA59419063296e7af89060240160206040518083038186803b1580156105c557600080fd5b505af41580156105d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105fd9190611032565b905061060881610291565b85848151811061062857634e487b7160e01b600052603260045260246000fd5b6020908102919091010152610640846001831b610e05565b935083811c91505b82610652816113af565b9350505b600182166107505760008561066c60018661134d565b8151811061068a57634e487b7160e01b600052603260045260246000fd5b602002602001015190506000866002866106a4919061134d565b815181106106c257634e487b7160e01b600052603260045260246000fd5b6020026020010151905080826040516020016106e8929190918252602082015260400190565b604051602081830303815290604052805190602001208760028761070c919061134d565b8151811061072a57634e487b7160e01b600052603260045260246000fd5b6020908102919091010152610740856001610e11565b9450600184901c93505050610656565b61051b565b826001146107c05760405162461bcd60e51b815260206004820152603260248201527f66756e6374696f6e20656e6465642062757420737461636b20686173206d6f7260448201527119481d1a185b881bdb9948195b195b595b9d60721b6064820152608401610179565b846000815181106107e157634e487b7160e01b600052603260045260246000fd5b60200260200101519750505050505050509392505050565b805160405163d82ae4b160e01b81526000917347573276feC7E1bEa2E33B3c3945d4aBFDdA59419163d82ae4b1916108379160040190815260200190565b60206040518083038186803b15801561084f57600080fd5b505af4158015610863573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108879190610f5d565b6108ec5760405162461bcd60e51b815260206004820152603060248201527f54686520696e707574206172726179206d75737420636f6e7461696e20706f7760448201526f6572206f66203220656c656d656e747360801b6064820152608401610179565b815160011415610926578160008151811061091757634e487b7160e01b600052603260045260246000fd5b6020026020010151905061031f565b600060018351901c6001600160401b0381111561095357634e487b7160e01b600052604160045260246000fd5b60405190808252806020026020018201604052801561097c578160200160208202803683370190505b50905060005b8351811015610a58578381815181106109ab57634e487b7160e01b600052603260045260246000fd5b6020026020010151848260016109c191906111d2565b815181106109df57634e487b7160e01b600052603260045260246000fd5b6020026020010151604051602001610a01929190918252602082015260400190565b6040516020818303038152906040528051906020012082600183901c81518110610a3b57634e487b7160e01b600052603260045260246000fd5b6020908102919091010152610a516002826111d2565b9050610982565b50610a62816107f9565b91505061031f565b6040516001600160c01b0319831660208201526000908190602801604051602081830303815290604052805190602001209050610aaa8560038386610ba9565b95945050505050565b600060038260ff161015610b095760405162461bcd60e51b815260206004820152601b60248201527f48617320746f206265206174206c65617374206f6e6520776f726400000000006044820152606401610179565b60408260ff161115610b2d5760405162461bcd60e51b815260040161017990611162565b60408051600060208083018290528351600881850301815260289093019093528151919092012060035b8460ff16811015610ba15760408051602081018490529081018390526060016040516020818303038152906040528051906020012091508080610b99906113af565b915050610b57565b509392505050565b600060038460ff161015610bf95760405162461bcd60e51b8152602060048201526017602482015276135d5cdd08189948185d081b19585cdd0818481ddbdc99604a1b6044820152606401610179565b60408460ff161115610c1d5760405162461bcd60e51b815260040161017990611162565b6000610c2a856002611255565b905085610c38600183611364565b166001600160401b0316600014610c915760405162461bcd60e51b815260206004820152601760248201527f506f736974696f6e206973206e6f7420616c69676e65640000000000000000006044820152606401610179565b610c9c85604061138c565b60ff16835114610cee5760405162461bcd60e51b815260206004820152601b60248201527f50726f6f66206c656e67746820646f6573206e6f74206d6174636800000000006044820152606401610179565b8360005b8451816001600160401b03161015610dfa576001600160401b038381168183161b891616610d83578185826001600160401b031681518110610d4457634e487b7160e01b600052603260045260246000fd5b6020026020010151604051602001610d66929190918252602082015260400190565b604051602081830303815290604052805190602001209150610de8565b84816001600160401b031681518110610dac57634e487b7160e01b600052603260045260246000fd5b602002602001015182604051602001610dcf929190918252602082015260400190565b6040516020818303038152906040528051906020012091505b80610df2816113ca565b915050610cf2565b509695505050505050565b600061028a82846111d2565b600061028a828461134d565b600061028a828461132e565b600082601f830112610e39578081fd5b813560206001600160401b0380831115610e5557610e55611407565b8260051b604051601f19603f83011681018181108482111715610e7a57610e7a611407565b60405284815283810192508684018288018501891015610e98578687fd5b8692505b85831015610eba578035845292840192600192909201918401610e9c565b50979650505050505050565b60008083601f840112610ed7578182fd5b5081356001600160401b03811115610eed578182fd5b602083019150836020828501011115610f0557600080fd5b9250929050565b80356001600160401b038116811461031f57600080fd5b600060208284031215610f34578081fd5b81356001600160401b03811115610f49578182fd5b610f5584828501610e29565b949350505050565b600060208284031215610f6e578081fd5b8151801515811461028a578182fd5b600080600060408486031215610f91578182fd5b83356001600160401b03811115610fa6578283fd5b610fb286828701610ec6565b909790965060209590950135949350505050565b600080600060408486031215610fda578283fd5b83356001600160401b03811115610fef578384fd5b610ffb86828701610ec6565b909450925050602084013561100f8161141d565b809150509250925092565b60006020828403121561102b578081fd5b5035919050565b600060208284031215611043578081fd5b5051919050565b60008060006060848603121561105e578283fd5b61106784610f0c565b925060208401356001600160c01b031981168114611083578283fd5b915060408401356001600160401b0381111561109d578182fd5b6110a986828701610e29565b9150509250925092565b600080600080608085870312156110c8578081fd5b6110d185610f0c565b935060208501356110e18161141d565b92506040850135915060608501356001600160401b03811115611102578182fd5b61110e87828801610e29565b91505092959194509250565b60006020828403121561112b578081fd5b813561028a8161141d565b600060208284031215611147578081fd5b815161028a8161141d565b6000828483379101908152919050565b60208082526028908201527f43616e6e6f7420626520626967676572207468616e20746865206d616368696e604082015267329034ba39b2b63360c11b606082015260800190565b600080858511156111b9578182fd5b838611156111c5578182fd5b5050820193919092039150565b600082198211156111e5576111e56113f1565b500190565b600060ff821660ff84168060ff03821115611207576112076113f1565b019392505050565b80825b6001808611611221575061124c565b818704821115611233576112336113f1565b8086161561124057918102915b9490941c938002611212565b94509492505050565b60006001600160401b03610f558160ff86168386166000826112795750600161028a565b816112865750600061028a565b816001811461129c57600281146112a6576112d3565b600191505061028a565b60ff8411156112b7576112b76113f1565b6001841b9150848211156112cd576112cd6113f1565b5061028a565b5060208310610133831016604e8410600b8410161715611306575081810a83811115611301576113016113f1565b61028a565b611313848484600161120f565b808604821115611325576113256113f1565b02949350505050565b6000816000190483118215151615611348576113486113f1565b500290565b60008282101561135f5761135f6113f1565b500390565b60006001600160401b0383811690831681811015611384576113846113f1565b039392505050565b600060ff821660ff8416808210156113a6576113a66113f1565b90039392505050565b60006000198214156113c3576113c36113f1565b5060010190565b60006001600160401b03808316818114156113e7576113e76113f1565b6001019392505050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b60ff8116811461142c57600080fd5b5056fe011b4d03dd8c01f1049143cf9c4c817e4b167f1d1b83e5c6f0f10d89ba1e7bce4d9470a821fbe90117ec357e30bad9305732fb19ddf54a07dd3e29f440619254ae39ce8537aca75e2eff3e38c98011dfe934e700a0967732fc07b430dd656a233fc9a15f5b4869c872f81087bb6104b7d63e6f9ab47f2c43f3535eae7172aa7f17d2dd614cddaa4d879276b11e0672c9560033d3e8453a1d045339d34ba601b9c37b8b13ca95166fb7af16988a70fcc90f38bf9126fd833da710a47fb37a55e68e7a427fa943d9966b389f4f257173676090c6e95f43e2cb6d65f8758111e30930b0b9deb73e155c59740bacf14a6ff04b64bb8e201a506409c3fe381ca4ea90cd5deac729d0fdaccc441d09d7325f41586ba13c801b7eccae0f95d8f3933efed8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e6163e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b72122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec517a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca892b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e152499af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8bf065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a233e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698caefdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d33abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf98dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f65d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f649929927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e6191b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c99876e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977ec61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f945ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f8647bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348cafff75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172dafa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e2496d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f6d1ab973982c7ccbe6c1fae02788e4422ae22282fa49cbdb04ba54a7a238c6fc41187451383460762c06d1c8a72b9cd718866ad4b689e10c9a8c38fe5ef045bd785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683916ca832592485093644e8760cd7b4c01dba1ccc82b661bf13f0e3f34acd6b88a26469706673582212204b6f9050c324d17fa1d681f78938b5fad965acf9138df4cc7787a7e65a179f6364736f6c63430008030033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c806382b0eab81161006557806382b0eab8146100d75780638492d93b146100ea578063a7342688146100fd578063d7304dd91461011057610087565b806334bd712d1461008c578063451a1055146100b157806349fd2697146100c4575b600080fd5b61009f61009a366004610f7d565b610123565b60405190815260200160405180910390f35b61009f6100bf36600461101a565b610291565b61009f6100d2366004610fc6565b610324565b61009f6100e5366004610f23565b6107f9565b61009f6100f836600461104a565b610a6a565b61009f61010b36600461111a565b610ab3565b61009f61011e3660046110b3565b610ba9565b6000600382901b81610136826008610e05565b9050848211156101825760405162461bcd60e51b8152602060048201526012602482015271776f7264206f7574206f6620626f756e647360701b60448201526064015b60405180910390fd5b8481116101c557610195818387896111aa565b6040516020016101a6929190611152565b604051602081830303815290604052805190602001209250505061028a565b60408051600880825281830190925260009160208201818036833701905050905060006101f28785610e11565b905060005b8181101561027b57888861020b8784610e05565b81811061022857634e487b7160e01b600052603260045260246000fd5b9050013560f81c60f81b83828151811061025257634e487b7160e01b600052603260045260246000fd5b60200101906001600160f81b031916908160001a90535080610273816113af565b9150506101f7565b50508051602090910120925050505b9392505050565b60008061029f836020610e1d565b90506102ac816020610e05565b6107a010156102f35760405162461bcd60e51b8152602060048201526013602482015272696e646578206f7574206f6620626f756e647360681b6044820152606401610179565b600080604051806107c001604052806107a081526020016114306107a091399290920160200151925050505b919050565b600060038260ff1610156103745760405162461bcd60e51b8152602060048201526017602482015276135d5cdd08189948185d081b19585cdd0818481ddbdc99604a1b6044820152606401610179565b60408260ff1611156103985760405162461bcd60e51b815260040161017990611162565b826103ba576103b36103ab60038461138c565b60ff16610291565b905061028a565b60006103c760038461138c565b60ff166001901b905084849050600382901b10156104275760405162461bcd60e51b815260206004820152601960248201527f6461746120697320626967676572207468616e206472697665000000000000006044820152606401610179565b6040516306c8e54b60e01b8152600385901c600482015260009073__$8b7ebe2a69e01741840a6648963dfd5409$__906306c8e54b9060240160206040518083038186803b15801561047857600080fd5b505af415801561048c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104b09190611136565b6104bb9060026111ea565b60ff1690506000816001600160401b038111156104e857634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015610511578160200160208202803683370190505b5090506000806000805b8684101561075557600384901b8a111561057a5761053a8b8b86610123565b85848151811061055a57634e487b7160e01b600052603260045260246000fd5b60209081029190910101528361056f816113af565b945050839150610648565b60405163052dcf5f60e31b81526004810185905273__$8b7ebe2a69e01741840a6648963dfd5409$__9063296e7af89060240160206040518083038186803b1580156105c557600080fd5b505af41580156105d9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105fd9190611032565b905061060881610291565b85848151811061062857634e487b7160e01b600052603260045260246000fd5b6020908102919091010152610640846001831b610e05565b935083811c91505b82610652816113af565b9350505b600182166107505760008561066c60018661134d565b8151811061068a57634e487b7160e01b600052603260045260246000fd5b602002602001015190506000866002866106a4919061134d565b815181106106c257634e487b7160e01b600052603260045260246000fd5b6020026020010151905080826040516020016106e8929190918252602082015260400190565b604051602081830303815290604052805190602001208760028761070c919061134d565b8151811061072a57634e487b7160e01b600052603260045260246000fd5b6020908102919091010152610740856001610e11565b9450600184901c93505050610656565b61051b565b826001146107c05760405162461bcd60e51b815260206004820152603260248201527f66756e6374696f6e20656e6465642062757420737461636b20686173206d6f7260448201527119481d1a185b881bdb9948195b195b595b9d60721b6064820152608401610179565b846000815181106107e157634e487b7160e01b600052603260045260246000fd5b60200260200101519750505050505050509392505050565b805160405163d82ae4b160e01b815260009173__$8b7ebe2a69e01741840a6648963dfd5409$__9163d82ae4b1916108379160040190815260200190565b60206040518083038186803b15801561084f57600080fd5b505af4158015610863573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108879190610f5d565b6108ec5760405162461bcd60e51b815260206004820152603060248201527f54686520696e707574206172726179206d75737420636f6e7461696e20706f7760448201526f6572206f66203220656c656d656e747360801b6064820152608401610179565b815160011415610926578160008151811061091757634e487b7160e01b600052603260045260246000fd5b6020026020010151905061031f565b600060018351901c6001600160401b0381111561095357634e487b7160e01b600052604160045260246000fd5b60405190808252806020026020018201604052801561097c578160200160208202803683370190505b50905060005b8351811015610a58578381815181106109ab57634e487b7160e01b600052603260045260246000fd5b6020026020010151848260016109c191906111d2565b815181106109df57634e487b7160e01b600052603260045260246000fd5b6020026020010151604051602001610a01929190918252602082015260400190565b6040516020818303038152906040528051906020012082600183901c81518110610a3b57634e487b7160e01b600052603260045260246000fd5b6020908102919091010152610a516002826111d2565b9050610982565b50610a62816107f9565b91505061031f565b6040516001600160c01b0319831660208201526000908190602801604051602081830303815290604052805190602001209050610aaa8560038386610ba9565b95945050505050565b600060038260ff161015610b095760405162461bcd60e51b815260206004820152601b60248201527f48617320746f206265206174206c65617374206f6e6520776f726400000000006044820152606401610179565b60408260ff161115610b2d5760405162461bcd60e51b815260040161017990611162565b60408051600060208083018290528351600881850301815260289093019093528151919092012060035b8460ff16811015610ba15760408051602081018490529081018390526060016040516020818303038152906040528051906020012091508080610b99906113af565b915050610b57565b509392505050565b600060038460ff161015610bf95760405162461bcd60e51b8152602060048201526017602482015276135d5cdd08189948185d081b19585cdd0818481ddbdc99604a1b6044820152606401610179565b60408460ff161115610c1d5760405162461bcd60e51b815260040161017990611162565b6000610c2a856002611255565b905085610c38600183611364565b166001600160401b0316600014610c915760405162461bcd60e51b815260206004820152601760248201527f506f736974696f6e206973206e6f7420616c69676e65640000000000000000006044820152606401610179565b610c9c85604061138c565b60ff16835114610cee5760405162461bcd60e51b815260206004820152601b60248201527f50726f6f66206c656e67746820646f6573206e6f74206d6174636800000000006044820152606401610179565b8360005b8451816001600160401b03161015610dfa576001600160401b038381168183161b891616610d83578185826001600160401b031681518110610d4457634e487b7160e01b600052603260045260246000fd5b6020026020010151604051602001610d66929190918252602082015260400190565b604051602081830303815290604052805190602001209150610de8565b84816001600160401b031681518110610dac57634e487b7160e01b600052603260045260246000fd5b602002602001015182604051602001610dcf929190918252602082015260400190565b6040516020818303038152906040528051906020012091505b80610df2816113ca565b915050610cf2565b509695505050505050565b600061028a82846111d2565b600061028a828461134d565b600061028a828461132e565b600082601f830112610e39578081fd5b813560206001600160401b0380831115610e5557610e55611407565b8260051b604051601f19603f83011681018181108482111715610e7a57610e7a611407565b60405284815283810192508684018288018501891015610e98578687fd5b8692505b85831015610eba578035845292840192600192909201918401610e9c565b50979650505050505050565b60008083601f840112610ed7578182fd5b5081356001600160401b03811115610eed578182fd5b602083019150836020828501011115610f0557600080fd5b9250929050565b80356001600160401b038116811461031f57600080fd5b600060208284031215610f34578081fd5b81356001600160401b03811115610f49578182fd5b610f5584828501610e29565b949350505050565b600060208284031215610f6e578081fd5b8151801515811461028a578182fd5b600080600060408486031215610f91578182fd5b83356001600160401b03811115610fa6578283fd5b610fb286828701610ec6565b909790965060209590950135949350505050565b600080600060408486031215610fda578283fd5b83356001600160401b03811115610fef578384fd5b610ffb86828701610ec6565b909450925050602084013561100f8161141d565b809150509250925092565b60006020828403121561102b578081fd5b5035919050565b600060208284031215611043578081fd5b5051919050565b60008060006060848603121561105e578283fd5b61106784610f0c565b925060208401356001600160c01b031981168114611083578283fd5b915060408401356001600160401b0381111561109d578182fd5b6110a986828701610e29565b9150509250925092565b600080600080608085870312156110c8578081fd5b6110d185610f0c565b935060208501356110e18161141d565b92506040850135915060608501356001600160401b03811115611102578182fd5b61110e87828801610e29565b91505092959194509250565b60006020828403121561112b578081fd5b813561028a8161141d565b600060208284031215611147578081fd5b815161028a8161141d565b6000828483379101908152919050565b60208082526028908201527f43616e6e6f7420626520626967676572207468616e20746865206d616368696e604082015267329034ba39b2b63360c11b606082015260800190565b600080858511156111b9578182fd5b838611156111c5578182fd5b5050820193919092039150565b600082198211156111e5576111e56113f1565b500190565b600060ff821660ff84168060ff03821115611207576112076113f1565b019392505050565b80825b6001808611611221575061124c565b818704821115611233576112336113f1565b8086161561124057918102915b9490941c938002611212565b94509492505050565b60006001600160401b03610f558160ff86168386166000826112795750600161028a565b816112865750600061028a565b816001811461129c57600281146112a6576112d3565b600191505061028a565b60ff8411156112b7576112b76113f1565b6001841b9150848211156112cd576112cd6113f1565b5061028a565b5060208310610133831016604e8410600b8410161715611306575081810a83811115611301576113016113f1565b61028a565b611313848484600161120f565b808604821115611325576113256113f1565b02949350505050565b6000816000190483118215151615611348576113486113f1565b500290565b60008282101561135f5761135f6113f1565b500390565b60006001600160401b0383811690831681811015611384576113846113f1565b039392505050565b600060ff821660ff8416808210156113a6576113a66113f1565b90039392505050565b60006000198214156113c3576113c36113f1565b5060010190565b60006001600160401b03808316818114156113e7576113e76113f1565b6001019392505050565b634e487b7160e01b600052601160045260246000fd5b634e487b7160e01b600052604160045260246000fd5b60ff8116811461142c57600080fd5b5056fe011b4d03dd8c01f1049143cf9c4c817e4b167f1d1b83e5c6f0f10d89ba1e7bce4d9470a821fbe90117ec357e30bad9305732fb19ddf54a07dd3e29f440619254ae39ce8537aca75e2eff3e38c98011dfe934e700a0967732fc07b430dd656a233fc9a15f5b4869c872f81087bb6104b7d63e6f9ab47f2c43f3535eae7172aa7f17d2dd614cddaa4d879276b11e0672c9560033d3e8453a1d045339d34ba601b9c37b8b13ca95166fb7af16988a70fcc90f38bf9126fd833da710a47fb37a55e68e7a427fa943d9966b389f4f257173676090c6e95f43e2cb6d65f8758111e30930b0b9deb73e155c59740bacf14a6ff04b64bb8e201a506409c3fe381ca4ea90cd5deac729d0fdaccc441d09d7325f41586ba13c801b7eccae0f95d8f3933efed8b96e5b7f6f459e9cb6a2f41bf276c7b85c10cd4662c04cbbb365434726c0a0c9695393027fb106a8153109ac516288a88b28a93817899460d6310b71cf1e6163e8806fa0d4b197a259e8c3ac28864268159d0ac85f8581ca28fa7d2c0c03eb91e3eee5ca7a3da2b3053c9770db73599fb149f620e3facef95e947c0ee860b72122e31e4bbd2b7c783d79cc30f60c6238651da7f0726f767d22747264fdb046f7549f26cc70ed5e18baeb6c81bb0625cb95bb4019aeecd40774ee87ae29ec517a71f6ee264c5d761379b3d7d617ca83677374b49d10aec50505ac087408ca892b573c267a712a52e1d06421fe276a03efb1889f337201110fdc32a81f8e152499af665835aabfdc6740c7e2c3791a31c3cdc9f5ab962f681b12fc092816a62f27d86025599a41233848702f0cfc0437b445682df51147a632a0a083d2d38b5e13e466a8935afff58bb533b3ef5d27fba63ee6b0fd9e67ff20af9d50deee3f8bf065ec220c1fd4ba57e341261d55997f85d66d32152526736872693d2b437a233e2337b715f6ac9a6a272622fdc2d67fcfe1da3459f8dab4ed7e40a657a54c36766c5e8ac9a88b35b05c34747e6507f6b044ab66180dc76ac1a696de03189593fedc0d0dbbd855c8ead673544899b0960e4a5a7ca43b4ef90afe607de7698caefdc242788f654b57a4fb32a71b335ef6ff9a4cc118b282b53bdd6d6192b7a82c3c5126b9c7e33c8e5a5ac9738b8bd31247fb7402054f97b573e8abb9faad219f4fd085aceaa7f542d787ee4196d365f3cc566e7bbcfbfd451230c48d804c017d21e2d8fa914e2559bb72bf0ab78c8ab92f00ef0d0d576eccdd486b64138a4172674857e543d1d5b639058dd908186597e366ad5f3d9c7ceaff44d04d1550b8d33abc751df07437834ba5acb32328a396994aebb3c40f759c2d6d7a3cb5377e55d5d218ef5a296dda8ddc355f3f50c3d0b660a51dfa4d98a6a5a33564556cf83c1373a814641d6a1dcef97b883fee61bb84fe60a3409340217e629cc7e4dcc93b85d8820921ff5826148b60e6939acd7838e1d7f20562bff8ee4b5ec4a05ad997a57b9796fdcb2eda87883c2640b072b140b946bfdf6575cacc066fdae04f6951e63624cbd316a677cad529bbe4e97b9144e4bc06c4afd1de55dd3e1175f90423847a230d34dfb71ed56f2965a7f6c72e6aa33c24c303fd67745d632656c5ef90bec80f4f5d1daa251988826cef375c81c36bf457e09687056f924677cb0bccf98dff81e014ce25f2d132497923e267363963cdf4302c5049d63131dc03fd95f65d8b6aa5934f817252c028c90f56d413b9d5d10d89790707dae2fabb249f649929927c21dd71e3f656826de5451c5da375aadecbd59d5ebf3a31fae65ac1b316a1611f1b276b26530f58d7247df459ce1f86db1d734f6f811932f042cee45d0e455306d01081bc3384f82c5fb2aacaa19d89cdfa46cc916eac61121475ba2e6191b4feecbe1789717021a158ace5d06744b40f551076b67cd63af60007f8c99876e1424883a45ec49d497ddaf808a5521ca74a999ab0b3c7aa9c80f85e93977ec61ce68b20307a1a81f71ca645b568fcd319ccbb5f651e87b707d37c39e15f945ea69e2f7c7d2ccc85b7e654c07e96f0636ae4044fe0e38590b431795ad0f8647bdd613713ada493cc17efd313206380e6a685b8198475bbd021c6e9d94daab2214947127506073e44d5408ba166c512a0b86805d07f5a44d3c41706be2bc15e712e55805248b92e8677d90f6d284d1d6ffaff2c430657042a0e82624fa3717b06cc0a6fd12230ea586dae83019fb9e06034ed2803c98d554b93c9a52348cafff75c40174a91f9ae6b8647854a156029f0b88b83316663ce574a4978277bb6bb27a31085634b6ec78864b6d8201c7e93903d75815067e378289a3d072ae172dafa6a452470f8d645bebfad9779594fc0784bb764a22e3a8181d93db7bf97893c414217a618ccb14caa9e92e8c61673afc9583662e812adba1f87a9c68202d60e909efab43c42c0cb00695fc7f1ffe67c75ca894c3c51e1e5e731360199e600f6ced9a87b2a6a87e70bf251bb5075ab222138288164b2eda727515ea7de12e2496d4fe42ea8d1a120c03cf9c50622c2afe4acb0dad98fd62d07ab4e828a94495f6d1ab973982c7ccbe6c1fae02788e4422ae22282fa49cbdb04ba54a7a238c6fc41187451383460762c06d1c8a72b9cd718866ad4b689e10c9a8c38fe5ef045bd785b01e980fc82c7e3532ce81876b778dd9f1ceeba4478e86411fb6fdd790683916ca832592485093644e8760cd7b4c01dba1ccc82b661bf13f0e3f34acd6b88a26469706673582212204b6f9050c324d17fa1d681f78938b5fad965acf9138df4cc7787a7e65a179f6364736f6c63430008030033",
  "libraries": {
    "CartesiMath": "0x47573276feC7E1bEa2E33B3c3945d4aBFDdA5941"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "calculateRootFromPowerOfTwo(bytes32[])": {
        "params": {
          "hashes": "The array containing power of 2 elements"
        },
        "returns": {
          "_0": "byte32 the root hash being calculated"
        }
      },
      "getEmptyTreeHashAtIndex(uint256)": {
        "details": "first index is keccak(0), second index is keccak(keccak(0), keccak(0))",
        "params": {
          "_index": "of hash wanted"
        }
      },
      "getHashOfWordAtIndex(bytes,uint256)": {
        "details": "if word is incomplete (< 8 bytes) it gets padded with zeroes",
        "params": {
          "_data": "array of bytes",
          "_wordIndex": "index of word inside the bytes to get the hash of"
        }
      },
      "getMerkleRootFromBytes(bytes,uint8)": {
        "details": "_data is padded with zeroes until is multiple of 8root is completed with zero tree until log2size is completehashes are taken word by word (8 bytes by 8 bytes)",
        "params": {
          "_data": "array of bytes to be merklelized",
          "_log2Size": "log2 of total size of the drive"
        }
      },
      "getPristineHash(uint8)": {
        "details": "using the precomputed EMPTY_TREE_HASHES is cheaper",
        "params": {
          "_log2Size": "log2 of size of the empty drive"
        },
        "returns": {
          "_0": "merkle root hash of the drive of size 1 << log2Size filled with zeros"
        }
      },
      "getRoot(uint64,bytes8,bytes32[])": {
        "params": {
          "_position": "position of word in drive",
          "_value": "word to include in drive",
          "proof": "array of siblings to generate merkle root"
        },
        "returns": {
          "_0": "new merkle root hash after _value inclusion"
        }
      },
      "getRootWithDrive(uint64,uint8,bytes32,bytes32[])": {
        "params": {
          "_drive": "drive to be included",
          "_logOfSize": "log2 of size of _drive",
          "_position": "position of _drive",
          "siblings": "_drive's so that merkle root can be calculated"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "calculateRootFromPowerOfTwo(bytes32[])": {
        "notice": "Calculate the root of Merkle tree from an array of power of 2 elements"
      },
      "getEmptyTreeHashAtIndex(uint256)": {
        "notice": "Gets precomputed hash of zero in empty tree hashes"
      },
      "getHashOfWordAtIndex(bytes,uint256)": {
        "notice": "Get the hash of a word in an array of bytes"
      },
      "getMerkleRootFromBytes(bytes,uint8)": {
        "notice": "get merkle root of generic array of bytes"
      },
      "getPristineHash(uint8)": {
        "notice": "Gets the pristine hash of a drive full of zeroes"
      },
      "getRoot(uint64,bytes8,bytes32[])": {
        "notice": "Gets merkle root of drive with _value on _position"
      },
      "getRootWithDrive(uint64,uint8,bytes32,bytes32[])": {
        "notice": "Gets merkle root hash of machine with drive _drive"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}